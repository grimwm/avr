{
  "name": "AVR",
  "tagline": "Code related to Atmel's AVR architecture, including the 3rd party Arduino product..",
  "body": "AVR Toolkit\r\n===========\r\n\r\nThis code supports AVR MCUs utilizing avr-libc by providing additional support\r\nlibraries for the PWMs and other handy hardware features.  It also has some\r\nincluded code and scripts for helping getting other devices setup that can\r\nbe used in conjunction with lots of robotic experiments and products,\r\nsuch as the PS3 Dual Shock Controller.\r\n\r\nIt is worth noting that at the moment, items not related directly to the AVR\r\nare mostly targeted at Raspberry Pi use.  They will work on other machines,\r\nbut some of the scripts may need to be modified.  I hope to change that after\r\nthings solidify more.\r\n\r\nPlease note that this code is covered by the MPLv2 license, which is quite\r\nliberal in how you can use it with your own software.  You may find its\r\ntext at <https://www.mozilla.org/en-US/MPL/2.0/>.  If you have questions\r\nabout it, the Internet is filled with FAQs, but I chose this license\r\nmostly for the benefit of everyone involved.\r\n\r\nBuild Requirements\r\n------------------\r\nGenerally speaking, this project has been tested under Linux.  It is likely\r\nto work under Windows with some finagling, but it hasn't been a focus of this\r\nproject at this time.  However, we accept pull requests, and we'd love to\r\ngive more people access to this set of tools.\r\n\r\nHaving said that, assuming you already have your favorite flavor of Linux\r\ninstalled, you will need these tools:\r\n\r\n  1. cmake\r\n  1. gcc-avr\r\n  1. libc-avr\r\n  1. avrdude\r\n\r\nUsage\r\n-----\r\nThere are two basic modes for building applications.  The first lets you build\r\nprograms for the AVR, and the second lets you build applications for the PC.\r\n\r\n    ./configure -b <build_dir> avr -mcu <mcu_type> -fcpu <hz>\r\n    OR\r\n    ./configure -b <build_dir> default\r\n    \r\n    cd <build_dir>\r\n    make\r\n\r\nThe command for installing programs is specific to each target architecture\r\nand will be outlined using examples.\r\n\r\n### Example AVR Code:\r\n\r\n    # Prepare a build directory for the ATmega88 with a CPU speed of 8 MHz.\r\n    ./configure -b build_avr avr -mcu atmega88 -fcpu 8000000\r\n    cd build_avr\r\n\r\n    # Currently, the cmake files assume you're using linuxgpio (e.g. on the\r\n    # Raspberry Pi) and have set everything up properly in /etc/avrdude.conf.\r\n    # See \"Raspberry Pi Setup\" for some tips on how to configure avrdude\r\n    # and properly connect your AVR directly to a Raspberry Pi.\r\n    #\r\n    # Then, to install the PWM code, for example:\r\n    make install_pwm\r\n    \r\n### Example PC Code:\r\n\r\n    ./configure -b build_pc default\r\n    cd build_pc\r\n\r\n    # Then, to build all control modules:\r\n    make\r\n\r\nRaspberry Pi Setup\r\n------------------\r\nSo, you're using a Raspberry Pi (RPi) to communicate with and program your AVR\r\nchips, are you?  Well, congratulations!  It's a fine little setup, and this\r\nsection of the notes is specifically to guide you through that setup\r\nprocess.  This document, however, will only talk about the SPI setup and will\r\nnot cover any specifics on how to power your AVR (hint: the RPi has power and\r\nground pins, and you should connect ALL the AVR ground pins up to a common\r\nground, btw).  While going through this section, you should refer\r\nto <http://pi.gadgetoid.com/pinout>.\r\n\r\nI apologize in advance for not providing any images or diagrams\r\njust yet.  I just want to get this information out to you in any form\r\npossible, even in a raw form, so that you might be able to get started.\r\n\r\nFirstly, we're going to assume you want to use the GPIO header to program\r\nyour AVR.  You are free to use whatever power source you want, but you have\r\nto make sure your AVR only sends 3.3v signals back to the RPi.  So, if you\r\npower the AVR using something other than the 3.3v (e.g. using the 3.3v\r\npower supply pin on the RPi), please buy a voltage level translator or build\r\nsomething yourself.  You do not want \"the magic smoke\".\r\n\r\nAnyway, you will be using the SPI pins on your RPi, which are the MOSI, MISO,\r\nand SCK pins.  You also need to use one of the digital output pins as your\r\n~RST signal for the AVR.  You should also connect the RPi's GND to your AVR,\r\neven if the AVR is connected to another power source, because it will create\r\na common ground.\r\n\r\nI'm not exactly an EE expert, but I don't think you should encounter any\r\nground loops (at least, I didn't, which, extrapolating from a sample size of 1,\r\nno one in the world should have probelems, haha).\r\n\r\nConnect the SCK pins on both the RPi and AVR directly together.  Then,\r\nconnect the MISO on the RPi to the MOSI on the AVR.  Next, quite obviously,\r\nconnect the MOSI on the RPi to the MISO on the AVR.  Finally, connect\r\nwhatever pin you designated as the ~RST signal pin to your AVR's ~RST pin.\r\nAnd by the way, it wouldn't hurt to put a pull-up resistor between the AVR's\r\n~RST pin and Vcc.\r\n\r\nMoving on, you're ready to setup `/etc/avrdude.conf` on your RPi to handle\r\ndata transfers with the SPI.  On my model B, I chose BCM 22, allowing me\r\nphysical pins {15,17,19,21,23,25}, which are located geographically close.\r\nSo, assuming you use BCM 22, this is what your `avrdude.conf` would look like\r\nfor \"linuxgpio\":\r\n\r\n    programmer\r\n      id    = \"linuxgpio\";\r\n      desc  = \"Use the Linux sysfs interface to bitbang GPIO lines\";\r\n      type  = \"linuxgpio\";\r\n      reset = 22;\r\n      sck   = 11;\r\n      mosi  = 10;\r\n      miso  = 9;\r\n    ;\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}